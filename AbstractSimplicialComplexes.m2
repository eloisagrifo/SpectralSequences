-- -*- coding: utf-8 -*-
--------------------------------------------------------------------------------
-- Copyright 2024  Nathan Grieve
--
-- This program is free software: you can redistribute it and/or modify it under
-- the terms of the GNU General Public License as published by the Free Software
-- Foundation, either version 3 of the License, or (at your option) any later
-- version.
--
-- This program is distributed in the hope that it will be useful, but WITHOUT
-- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
-- FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
-- details.
--
-- You should have received a copy of the GNU General Public License along with
-- this program.  If not, see <http://www.gnu.org/licenses/>.
--------------------------------------------------------------------------------


newPackage(
    "AbstractSimplicialComplexes",
    Version => "0.1",
    Date => "",
    Headline => "AbstractSimplicialComplexes",
    Authors => {{ Name => "Nathan Grieve", Email => "nathan.m.grieve@gmail.com", HomePage => "https://sites.google.com/view/nathan-grieve"}},
    AuxiliaryFiles => false,
    DebuggingMode => false
    )

export {"SimplicialSet", "simplicialSet","SimplicialChainComplex","simplicialChainComplex", "reducedSimplicialChainComplex", "ambientSimplicialSetSize",
    "ambientSimplicialSet","inducedKFaceSimplicialChainComplexMap"}

-* Code section *-

---------------------------------------
-- spots
----------------------------------------
-- the spots method is extremely useful
-----------------------------------------

spots = method()

---------------------------------------
--------------------------------------

--------------------------
-- simplicial set
-------------------------

-- The idea is to make a SimplicalSet as a Type of HashTable as a means
-- For working with AbstractSimplicial Complexes ---
-- The integer keys will output the list of i-simplicies

SimplicialSet = new Type of HashTable
SimplicialSet.synonym = "simplicial set"

--SimplicialSet.GlobalAssignHook = globalAssignFunction
--SimplicialSet.GlobalReleaseHook = globalReleaseFunction
--describe SimplicialSet := K -> net expression K


new SimplicialSet := SimplicialSet =>(cl) -> (
    K := newClass(SimplicialSet, new HashTable); -- sigh
    K)

spots SimplicialSet := List => (
  K -> sort select(keys K, i -> class i === ZZ))


SimplicialSet _ ZZ := SimplicialSet => (K,p) -> (
  if K#?p then K#p 
  )



--- Constructors for SimplicialSets

simplicialSet = method()

----  We need to make a sort of ``main primitive constructor" for simplicial sets
----  We need to make a method perhaps to check if a simplicial set is a simplicial complex (i.e., to check closure under taking subsets of a face)


-- the most basic constructor of a SimplicialSet

-- The idea is to make a simplical set starting from a list of faces.
--  The list of faces need not be facets.
--  The constructor returns the simplicial complex (with all of its faces) that is
--  generated by this list of faces 
--  By default, it is assumed that the kfaces are all lex ordered positive integers 

makeKFaces := (L,k) -> (
    toList(set(flatten(apply(#L, i -> subsets(L_i,k)))))
    )

makeAllFaces := (L) -> (
    numberOfFaces := #L;
--  find the highest dimensional face    
    n := max(apply(numberOfFaces, i-> # (L_i)));
    flatten(for k from 0 to n list {k-1 => makeKFaces(L,k)})
    )


simplicialSet(List) := SimplicialSet => L -> (
    return new SimplicialSet from makeAllFaces(L)
    )


--- The following method will make the (n-1)-dimensional n-simplex on [n] = {1,...,n}
simplicialSet(ZZ) := SimplicialSet => (n) -> (
    L := for i from 1 to n list i;
    return simplicialSet({L})
    )


ambientSimplicialSetSize = method() -- return the size of the underyling ambient simplex

ambientSimplicialSetSize(SimplicialSet) := (K) -> (
    max flatten(K_0)
    )


ambientSimplicialSet = method() -- return the underlying ambient simplex 


ambientSimplicialSet(SimplicialSet) := SimplicialSet => (K) -> (
    return simplicialSet(ambientSimplicialSetSize(K))
    )

---
-- Another method that could be added later is a script to check that a proposed "SimplicialSet"
-- is indeed a "SimplicialSet" i.e., that the closure property on subsets is indeed satisfied
--  this is something that we will postpone for the present time

---------

--  There are many ways to approach 
--  The simplical boundary map
-- For X a given simplicial complex
--  Perhaps the most straight forward way
--  is via 
-- \partial_k : C_k(X) \rightarrow C_{k-1}(X)
-- Here C_k(X) is the free 
-- \ZZ-module (or \kk-vector space)
-- on the set of k+1 simplicies 
-- (i.e., the set of k+1 combinations
-- of {1,...,n})

  
--  There are many ways to approach 
--  The simplical boundary map
-- For X a given simplicial complex
--  Perhaps the most straight forward way
--  is via 
-- \partial_k : C_k(X) \rightarrow C_{k-1}(X)
--  Here C_k(X) is the free 
-- \ZZ-module (or \kk-vector space)
-- on the set of k+1 simplicies 
-- (i.e., the set of k+1 combinations
-- of {1,...,n})

--  Given input a k+1 lex segment a = [a_0,...,a_k] ---- i.e., a k-face
--  Compute its image under the boundary map
--  It seems most straight forward to give the 
-- output as a k+1 tuple with entry i having the
-- form [(-1)^i,d_i(a)]
-- here d_i(a) is a with the i-th lex entry removed
--  the following is more simply just for
-- testing purposes and is not used explicitly in the sequel
--partial := (L) -> ( 
 -- apply(0 .. (#L-1), i -> {(-1)^i, drop(L,{i,i})})

 
-- The following function seems useful to  
-- useful to construct
-- the simplicial chain complex map
-- given a k-face y and a k+1 - face x
-- decide if it equals \partial(x,i)
-- for some i


isDLexSeqI := (y,x) -> (
    k := #y;
    sign := 0;
    for i from 0 to # x do (
        z := drop(x,{i,i});
        if y == z then (sign = (-1)^i;
            break);
);
return sign
)


-- make a constructor for making matrices
-- that represented the simplicial boundary
-- maps of a given simplical complex
-- what follows appears to work OK
--  more testing is required.

simplicialMakeMatrix := (kPlusOneFaces,kFaces) -> (
    n := # kPlusOneFaces;
    m := # kFaces;
    matrixList := 
    for j from 0 to n-1 list (
	for i from 0 to m-1 list (
	   isDLexSeqI((kFaces)#i,(kPlusOneFaces)#j))
	);
    return matrix(matrixList)
)


--
--
---  It seems sensible to make a new Type "SimplicialChainComplex" as a new type of ChainComplex ---

SimplicialChainComplex = new Type of ChainComplex
SimplicialChainComplex.synonym = "Simplicial Chain Complex"

spots SimplicialChainComplex := List => (
  K -> sort select(keys K, i -> class i === ZZ))


--  We can finally make the entire reduced homology chain complex in the following way
-- Given as input the simplcial complex represented as a simplicial set --
--  This will produce the reduced chain complex (so the empty set will
--  appear in the chain complex)
-- At present the scripted functor HH is not supported on the output of this method
-- However the homology modules can be determined via "homology(i,C)"

reducedSimplicialChainComplex = method() -- return the chain complex (with contribution from the empty face) that is associated to a simplicial set (i.e., an abstract simplicial complex)

reducedSimplicialChainComplex(SimplicialSet) := SimplicialChainComplex => (L) ->
(
    n := max spots L;
    C := new ChainComplex;
    mapsList := reverse(for i from 0 to n list simplicialMakeMatrix(L#i,L#(i-1)));
    for i from 0 to n do (
    C.dd_(i) = mapsList_i;
	);
   C.dd_(-1) = map(ZZ^0,C_(-1),zero);
    C.dd_(n+1) = map(C_n,ZZ^0,zero);  
    return C
	)

simplicialChainComplex = method() --  return the non-reduced simplicial chain complex (i.e., the chain complex with no contribution from the empty face)

simplicialChainComplex(SimplicialSet) := SimplicialChainComplex => (L) ->
(
    n := max spots L;
    C := new ChainComplex;
    mapsList := reverse(for i from 0 to n list simplicialMakeMatrix(L#i,L#(i-1)));
    for i from 1 to n do (
    C.dd_(i) = mapsList_i;
	);
   C.dd_(0) = map(ZZ^0,C_(0),zero);
    C.dd_(n+1) = map(C_n,ZZ^0,zero);  
    return C
	)

    
---  Another method that would be of interest,
--  is given an inclusion (or more general a morphism)
---- of simplicial sets, then compute the induced chain complex morphism of SimplicialChainComplexes
---  But this is omitted for now
--- An important special case would be to view a
--  sub simplicial set of the full simplicial set (simplex) and then to compute
--- the corresponding induced inclusion morphism.
--- For this at least, we want to regard everything as lex ordered for simplicity.


---  Actually perhaps better will be to make an k-face inclusion map given an inclusion of simplicial sets 
---  Assume that L <= H
---  If L_k has no faces then the method returns an error message
---  Otherwise the method produces the appropriate matrix
---  That induces the corresponding inclusion map

inducedKFaceSimplicialChainComplexMap = method()

inducedKFaceSimplicialChainComplexMap(ZZ,SimplicialSet,SimplicialSet) := (k,H,L) ->
(
M := L_k;
N := H_k;
n := # M;
m := # N;
myMatrixList := for i from 0 to m-1 list (
    for j from 0 to n-1 list (
	if N#i == M#j then 1 else 0 
	)
    );
return matrix myMatrixList
)

-----
 
-* Documentation section *-
beginDocumentation()

document { 
  Key => AbstractSimplicialComplexes,
  Headline => "a package for working with abstract simplicial complexes",
  "In this package, by a slight abuse of termionalogy we mostly refer to abstract simplicial complexes as 'SimplicialSets'.  By our viewpoint, `abstract simplicial complexes' have vertices 
supported on the set [n] := {1,...,n}.
  The aim of this package is to provide a methology for working with such objects directly.  We are especially interested in homological aspects thereof; in particular
we provide methods for working with the chain complexes that are associated to each abstract simplicial complex."
 }


--------------------------------------------
-- Documentation of methods and functions --
--------------------------------------------

--
-- Types
--

doc ///
     Key
     	  SimplicialSet
     Headline
     	  the type of all simplicial sets
     Description
     	  Text	  
	     The type SimplicialSet is a data type for working with
	     abstract simplicial complexes with vertices supported on [n] = {1,...,n}.
--     Caveat

--    SeeAlso
///


doc ///
     Key
     	  SimplicialChainComplex
     Headline
     	  the type of all simplicial chain complexes
     Description
     	  Text	  
	     The type SimplicialChainComplex is a data type for working with the homological
	     chain complexes that are obtained from those abstract
	     simplicial complexes which have vertices supported on [n] = {1,...,n}.
--     Caveat

--    SeeAlso
///


--
-- Functions and Commands
--

doc ///
     Key
     	  ambientSimplicialSet
	  (ambientSimplicialSet,SimplicialSet)
     Headline
     	  the ambient simplex
     Description
     	  Text	  
	     If an abstract simplicial complex has vertices supported on a subset of [n] = {1,...,n], and including n,
	     then it seems useful to regard this simplicial complex as being a subsimplicial
	     complex of the simplex on [n].  This method returns this simplex as
	     the ambient simplical complex.
	  Example
	       K = simplicialSet({{1,2},{3}})
	       J = ambientSimplicialSet(K)
   
--     Caveat

--    SeeAlso
///


doc ///
     Key
     	  ambientSimplicialSetSize
	  (ambientSimplicialSetSize,SimplicialSet)
     Headline
     	  the ambient simplex size
     Description
     	  Text	  
	     If an abstract simplicial complex has vertices supported on a subset of [n] = {1,...,n], and including n,
	     then it seems useful to regard this simplicial complex as being a subsimplicial
	     complex of the simplex on [n].  This method simply returns this largest integer n.
	  Example
	       K = simplicialSet({{1,2},{3}})
	       J = ambientSimplicialSetSize(K)
--     Caveat

--    SeeAlso
///

doc ///
     Key
     	  inducedKFaceSimplicialChainComplexMap
	  (inducedKFaceSimplicialChainComplexMap,ZZ,SimplicialSet,SimplicialSet)
     Headline
     	  induced maps that arise via inclusions of abstract simplicial complexes
     Description
     	  Text	  
	     If an abstract simplicial complex can be regarded as a subsimplicial complex of another
	     abstract simplicial complex, then it is useful to calculate the induced map at the level of
	     SimplicialChainComplexes.  For a given homological degree k, this is made
	     possible by the method inducedKFaceSimplicialChainComplexMap.
	  Example
	       K = simplicialSet({{1,2},{3}})
	       J = ambientSimplicialSet(K)
	       inducedKFaceSimplicialChainComplexMap(1,J,K)
     Caveat
          Text
               If K has no k-faces then inducedKFaceSimplicialChainComplexMap(k,J,K)
	       will return an error message.
--    SeeAlso
///


doc ///
     Key
     	  reducedSimplicialChainComplex
	  (reducedSimplicialChainComplex,SimplicialSet)
     Headline
     	  The reduced homological chain complex that is determined by an abstract simplicial complex 
     Description
     	  Text	  
	     This method returns the reduced homological chain complex (i.e., there is a nonzero term in
		 homological degree -1 that corresponds to the empty face) that is asociated
	     to an abstract simplicial complex.  The chain complex is defined over the integers.
          Example
	       K = simplicialSet({{1,2,3},{2,4,9},{1,2,3,5,7,8},{3,4}})
	       reducedSimplicialChainComplex(K)
     Caveat
          Text
	     At the moment, the scripted homology functor is not supported and so
	     the homology groups have to be calculated using
	     the command homology(i,C).
--    SeeAlso
///


doc ///
     Key
     	  simplicialChainComplex
	  (simplicialChainComplex,SimplicialSet)
     Headline
     	  The non-reduced homological chain complex that is determined by an abstract simplicial complex 
     Description
     	  Text	  
	     This method returns the (non-reduced) homological chain complex (i.e., there is no nonzero term in
		 homological degree -1 that corresponds to the empty face) that is asociated
	     to an abstract simplicial complex.  The chain complex is defined over the integers.
	  Example
	       K = simplicialSet({{1,2,3},{1,4,5},{2,4,5,7}})
	       C = simplicialChainComplex(K)
     Caveat
          Text
	     At the moment, the scripted homology functor is not supported and so
	     the homology groups have to be calculated using
	     the command homology(i,C).
--    SeeAlso
///

doc ///
     Key
     	  simplicialSet
	  (simplicialSet,List)
	  (simplicialSet,ZZ)
     Headline
     	  The simplicialSet that is determined by an abstract simplicial complex 
     Description
     	  Text	  
	     This method returns the SimplicialSet that represents a
	     given abstract simplicial complex.
	     The input is either a given collection of generating faces or an integer.
	     These facets need not
	     be facets.  However, it is assumed that the faces are written
	     in lexiographic order.  When the input is an integer, the output is the
	     corresponding simplex.
	  Example
	       simplicialSet({{1,2,3,4}})
	       simplicialSet({{1,2,3,4}, {2,3,5},{1,5}})
	       simplicialSet(4)
	           
--     Caveat

--    SeeAlso
///


doc ///
     Key
     	  (symbol _, SimplicialSet, ZZ)
     Headline
     	  The k faces of a simplicial set  
     Description
     	  Text	  
	     This method returns the collection of k faces of a given SimplicialSet.
	  Example
	       K = simplicialSet(3)
	       K_3
	       K_2
	       K_1
	       K_0
	       K_(-1)
--     Caveat

--    SeeAlso
///



-* Test section *-
TEST /// -* [insert short title for this test] *-
-- test code and assertions here
-- may have as many TEST sections as needed
///

end--

-* Development section *-
restart
debug needsPackage "AbstractSimplicialComplexes"
check "AbstractSimplicialComplexes"

uninstallPackage "AbstractSimplicialComplexes"

--
--

restart
uninstallPackage "AbstractSimplicialComplexes"
installPackage("AbstractSimplicialComplexes", RemakeAllDocumentation => true)

viewHelp

loadPackage("AbstractSimplicialComplexes", Reload => true)

--
--


